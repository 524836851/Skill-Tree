# 应用层

## Http协议相关

### https安全协议

1. 对称加密算法，加密效率高，但是一旦密钥被泄露了就无效了

2. 非对称称加密算法，加密效率低，但是没有密钥泄露风险，可以直接暴露公钥。鉴于其加密效率低，因此实际使用中使用这个算法来**交换对称加密算法中的密钥**。一般是服务端发送公钥，然后客户端使用该公钥加密一个随机密钥，服务端再使用私钥解密出密钥。这样就在没有泄露密钥情况算法下，可以使用对称加密算法愉快地加密通信过程。

   **因此这里引出了另一个问题，如何确保公钥确实来自想要访问的服务器？** 这里问题归结为如何证明某个信息来自某个身份，解决的核心思想就是非对称加密算法。即私钥加密，公钥解密。一般待验证方同时持有公钥私钥，它将信息加密后连同公钥一起发给解密方， 当解密方使用公钥解密后与原有的信息比较相同，即可证明信息确实来自验证方。注意这里虽然加密了信息，但是**重点在于验证身份而不是加密**，因为原信息本身是一起被发送的，是直接公开暴露的。又由于非对称加密算法效率低，因此通常是对信息的哈希值加密。

3. 数字签名算法，用于数字证书中，通常用来进行身份认证。虽然上述非对称加密解决了验证身份问题，但关键在于传递的公钥（这里的公钥不是第二点中的公钥，是需要对数字签名解密的公钥，数字签名中包含的信息是第二点中需要使用的公钥）有可能被完全替换，依然存在不可信问题。解决的问题就是需要找到一个可信的公钥，这里就引出了CA（数字认证机构），它就充当了这个可信的公钥角色。 

4. 服务器将公钥即个人信息等注册到CA，CA用自己的私钥对这些信息进行加密形成数字签名。服务器将数字证书（包含服务器公钥信息及数字签名）使用CA的公钥（这个注册到操作系统和浏览器中）进行解密，对比验证通过后，就可以认为数字证书中的服务器的公钥是可信。这就可以跳到了第二点。

**常见名词解释**

.key  私钥

.csr 根据私钥生成的公钥 + 个人信息

.crt(数字证书) .csr明文信息 + signature(使用CA私钥对.csr明文哈希值加密结果)

因此CA.crt 里面即有CA的公钥明文信息，因此可以用来检查该CA签发的数字证书。



**openssl 命令：**

`openssl genrsa -out server.key 2048`可以用于生成私钥

`openssl rsa -in server.key -out server.key.public`  基于公钥生成私钥

`openssl req -new -x509 -key server.key -out server.crt -days 365` 基于私钥生成公钥，同时使用私钥将公钥信息加密生成签名，即生成自签名的数字证书

`openssl x509 -req -in device.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out device.crt -days 5000`  这里使用第三方CA的私钥（rootCA.key)对信息（公钥+个人信息，即device.csr）加密生成数字证书（即device.crt) 这个device.crt就需要使用CA.crt来解密

### https实现过程

